Certainly! Here's a full example using Quarkus Panache with a composite primary key:

```java
import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.IdClass;

@Entity
@IdClass(YourCompositeKeyClass.class)
public class YourEntity extends PanacheEntityBase {

    @Id
    @Column(name = "first_key")
    public String firstKey;

    @Id
    @Column(name = "second_key")
    public String secondKey;

    // Other fields and methods...

    public static YourEntity findByIds(String firstKey, String secondKey) {
        return find("firstKey = ?1 and secondKey = ?2", firstKey, secondKey).firstResult();
    }
}
```

And the composite key class:

```java
import java.io.Serializable;
import java.util.Objects;

public class YourCompositeKeyClass implements Serializable {

    private String firstKey;
    private String secondKey;

    // Constructors, getters, setters...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        YourCompositeKeyClass that = (YourCompositeKeyClass) o;
        return Objects.equals(firstKey, that.firstKey) &&
               Objects.equals(secondKey, that.secondKey);
    }

    @Override
    public int hashCode() {
        return Objects.hash(firstKey, secondKey);
    }
}
```

This example shows an entity `YourEntity` with a composite primary key consisting of two columns (`firstKey` and `secondKey`). You can use the `findByIds` method to query by these composite keys. Ensure your database schema supports composite keys for this to work seamlessly.