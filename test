I see, if you're dealing with version numbers where each part is treated as a decimal and you want to find the maximum version correctly, you should consider splitting the version string and comparing each part numerically. Here's an adjusted example for your scenario:

```java
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.JpaRepository;

public interface YourEntityRepository extends JpaRepository<YourEntity, Long> {

    @Query("SELECT e " +
           "FROM YourEntity e " +
           "ORDER BY CAST(SUBSTRING_INDEX(e.columnName, '.', 1) AS UNSIGNED) DESC, " +
           "         CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(e.columnName, '.', -2), '.', 1) AS UNSIGNED) DESC, " +
           "         CAST(SUBSTRING_INDEX(e.columnName, '.', -1) AS UNSIGNED) DESC")
    YourEntity findMaxXYZPattern();
}
```

This query orders the results in descending order based on each part of the version number, ensuring that you get the row with the highest version first. Adjust the column and entity names accordingly based on your actual setup.